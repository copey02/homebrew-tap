#!/usr/bin/env python3
"""
Tracker CLI - Search and download torrents from private trackers
Supports: Beyond-HD, Hawke/FNP (UNIT3D), FileList, TorrentLeech
"""

import argparse
import json
import os
import re
import sys
import urllib.request
import urllib.parse
import urllib.error
import time
from pathlib import Path

CONFIG_PATH = Path(os.environ.get(
    "TKCLI_CONFIG_PATH",
    str(Path.home() / ".config" / "trackers" / "config.json")
))
TORRENT_CONFIG_PATH = Path(os.environ.get(
    "TRTCLI_CONFIG_PATH",
    os.environ.get("TORRENT_CONFIG_PATH", str(Path.home() / ".config" / "torrent" / "config.json"))
))
VERSION = "1.3.3"
USER_AGENT = f"TKCLI/{VERSION} (+https://github.com/copey02/homebrew-tap)"

# Resolution mappings for UNIT3D trackers
UNIT3D_RESOLUTIONS = {
    "2160p": "2",
    "4k": "2",
    "1080p": "3",
    "720p": "5",
}

def request_json(url, headers=None, data=None, method="GET", retries=3):
    headers = headers or {}
    headers.setdefault("User-Agent", USER_AGENT)

    for attempt in range(retries):
        req = urllib.request.Request(url, data=data, headers=headers, method=method)
        try:
            with urllib.request.urlopen(req, timeout=30) as resp:
                return json.loads(resp.read().decode())
        except urllib.error.HTTPError as e:
            if e.code in {429, 500, 502, 503, 504} and attempt < retries - 1:
                retry_after = e.headers.get("Retry-After")
                backoff = int(retry_after) if retry_after and retry_after.isdigit() else 2 ** attempt
                time.sleep(backoff)
                continue
            raise
        except urllib.error.URLError as e:
            if attempt < retries - 1:
                time.sleep(2 ** attempt)
                continue
            raise


def request_bytes(url, headers=None, data=None, method="GET", retries=3):
    headers = headers or {}
    headers.setdefault("User-Agent", USER_AGENT)

    for attempt in range(retries):
        req = urllib.request.Request(url, data=data, headers=headers, method=method)
        try:
            with urllib.request.urlopen(req, timeout=30) as resp:
                return resp.read(), resp.headers
        except urllib.error.HTTPError as e:
            if e.code in {429, 500, 502, 503, 504} and attempt < retries - 1:
                retry_after = e.headers.get("Retry-After")
                backoff = int(retry_after) if retry_after and retry_after.isdigit() else 2 ** attempt
                time.sleep(backoff)
                continue
            raise
        except urllib.error.URLError:
            if attempt < retries - 1:
                time.sleep(2 ** attempt)
                continue
            raise

def load_config():
    if not CONFIG_PATH.exists():
        print(f"Error: Config file not found at {CONFIG_PATH}")
        print("Create it with tracker configs. See --help for format.")
        sys.exit(1)
    try:
        with open(CONFIG_PATH) as f:
            return json.load(f)
    except json.JSONDecodeError:
        print(f"Error: invalid JSON in {CONFIG_PATH}", file=sys.stderr)
        sys.exit(1)
    except OSError as e:
        print(f"Error reading config: {e}", file=sys.stderr)
        sys.exit(1)


def load_torrent_config():
    """Load torrent client config for trtcli integration"""
    if not TORRENT_CONFIG_PATH.exists():
        return None
    try:
        with open(TORRENT_CONFIG_PATH) as f:
            return json.load(f)
    except json.JSONDecodeError:
        print(f"Error: invalid JSON in {TORRENT_CONFIG_PATH}", file=sys.stderr)
        return None
    except OSError as e:
        print(f"Error reading torrent config: {e}", file=sys.stderr)
        return None


def add_to_torrent_client(url, trt_config, torrent_data=None):
    """Add torrent URL or raw data to configured torrent client (Transmission or qBittorrent)"""
    import base64

    client = trt_config.get("client", "transmission").lower()

    if torrent_data:
        # Add by raw torrent file data
        if client == "qbittorrent":
            return add_to_qbittorrent_file(torrent_data, trt_config)
        else:
            return add_to_transmission_file(torrent_data, trt_config)
    else:
        # Add by URL
        if client == "qbittorrent":
            return add_to_qbittorrent(url, trt_config)
        else:
            return add_to_transmission_url(url, trt_config)


def add_to_qbittorrent_file(torrent_data, config):
    """Add torrent by raw file data to qBittorrent"""
    import base64

    base_url = config["url"].rstrip("/")
    username = config.get("username", "")
    password = config.get("password", "")

    # Login first
    login_data = urllib.parse.urlencode({
        "username": username,
        "password": password
    }).encode()

    cookie = None
    try:
        _, resp_headers = request_bytes(
            f"{base_url}/api/v2/auth/login",
            headers={"Content-Type": "application/x-www-form-urlencoded"},
            data=login_data,
            method="POST",
        )
        cookie = resp_headers.get("Set-Cookie", "").split(";")[0]
    except Exception as e:
        return False, f"qBittorrent login failed: {e}"

    # Add torrent via multipart form data
    boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW"
    body = (
        f"--{boundary}\r\n"
        f'Content-Disposition: form-data; name="torrents"; filename="torrent.torrent"\r\n'
        f"Content-Type: application/x-bittorrent\r\n\r\n"
    ).encode() + torrent_data + f"\r\n--{boundary}--\r\n".encode()

    headers = {
        "Cookie": cookie,
        "Content-Type": f"multipart/form-data; boundary={boundary}"
    }

    try:
        content, _ = request_bytes(
            f"{base_url}/api/v2/torrents/add",
            headers=headers,
            data=body,
            method="POST",
        )
        text = content.decode() if isinstance(content, (bytes, bytearray)) else str(content)
        if text == "Ok.":
            return True, "Added to qBittorrent"
        return False, f"qBittorrent error: {text}"
    except Exception as e:
        return False, f"qBittorrent error: {e}"


def add_to_transmission_file(torrent_data, config):
    """Add torrent by raw file data to Transmission"""
    import base64

    rpc_url = config["url"]
    auth_header = None
    if config.get("username") and config.get("password"):
        creds = f"{config['username']}:{config['password']}"
        auth_header = "Basic " + base64.b64encode(creds.encode()).decode()

    headers = {"Content-Type": "application/json", "User-Agent": USER_AGENT}
    if auth_header:
        headers["Authorization"] = auth_header

    # Get session ID
    session_id = None
    try:
        req = urllib.request.Request(rpc_url, headers=headers, method="POST", data=b"{}")
        urllib.request.urlopen(req, timeout=10)
    except urllib.error.HTTPError as e:
        if e.code == 409:
            session_id = e.headers.get("X-Transmission-Session-Id")
        else:
            return False, f"Transmission error: {e}"

    if session_id:
        headers["X-Transmission-Session-Id"] = session_id

    # Transmission expects base64-encoded torrent data
    metainfo = base64.b64encode(torrent_data).decode()

    body = json.dumps({
        "method": "torrent-add",
        "arguments": {"metainfo": metainfo}
    }).encode()

    try:
        result = request_json(rpc_url, headers=headers, data=body, method="POST")
        if result.get("result") == "success":
            added = result.get("arguments", {}).get("torrent-added", {})
            name = added.get("name", "Unknown")
            return True, f"Added to Transmission: {name}"
        return False, f"Transmission error: {result.get('result', 'Unknown')}"
    except Exception as e:
        return False, f"Transmission error: {e}"


def download_tl_torrent(url, tracker_config):
    """Download torrent file from TorrentLeech using session auth"""
    base_url = tracker_config["url"].rstrip("/")
    username = tracker_config.get("username")
    password = tracker_config.get("password")

    if not username or not password:
        return None, "TL requires username/password"

    # Login
    cookies, err = torrentleech_login(base_url, username, password)
    if err:
        return None, err

    # Download torrent file
    try:
        content, _ = request_bytes(
            url,
            headers={
                "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)",
                "Cookie": cookies,
            },
        )
        return content, None
    except Exception as e:
        return None, f"Download failed: {e}"


def add_to_qbittorrent(url, config):
    """Add torrent URL to qBittorrent"""
    base_url = config["url"].rstrip("/")
    username = config.get("username", "")
    password = config.get("password", "")

    # Login first
    login_data = urllib.parse.urlencode({
        "username": username,
        "password": password
    }).encode()

    cookie = None
    try:
        _, resp_headers = request_bytes(
            f"{base_url}/api/v2/auth/login",
            headers={"Content-Type": "application/x-www-form-urlencoded"},
            data=login_data,
            method="POST",
        )
        cookie = resp_headers.get("Set-Cookie", "").split(";")[0]
    except Exception as e:
        return False, f"qBittorrent login failed: {e}"

    # Add torrent
    add_data = urllib.parse.urlencode({"urls": url}).encode()
    headers = {"Cookie": cookie} if cookie else {}

    try:
        content, _ = request_bytes(
            f"{base_url}/api/v2/torrents/add",
            headers=headers,
            data=add_data,
            method="POST",
        )
        text = content.decode() if isinstance(content, (bytes, bytearray)) else str(content)
        if text == "Ok.":
            return True, "Added to qBittorrent"
        return False, f"qBittorrent error: {text}"
    except Exception as e:
        return False, f"qBittorrent error: {e}"


def add_to_transmission_url(url, config):
    """Add torrent URL to Transmission"""
    import base64

    rpc_url = config["url"]
    auth_header = None
    if config.get("username") and config.get("password"):
        creds = f"{config['username']}:{config['password']}"
        auth_header = "Basic " + base64.b64encode(creds.encode()).decode()

    headers = {"Content-Type": "application/json", "User-Agent": USER_AGENT}
    if auth_header:
        headers["Authorization"] = auth_header

    # Get session ID
    session_id = None
    try:
        req = urllib.request.Request(rpc_url, headers=headers, method="POST", data=b"{}")
        urllib.request.urlopen(req, timeout=10)
    except urllib.error.HTTPError as e:
        if e.code == 409:
            session_id = e.headers.get("X-Transmission-Session-Id")
        else:
            return False, f"Transmission error: {e}"

    if session_id:
        headers["X-Transmission-Session-Id"] = session_id

    body = json.dumps({
        "method": "torrent-add",
        "arguments": {"filename": url}
    }).encode()

    try:
        result = request_json(rpc_url, headers=headers, data=body, method="POST")
        if result.get("result") == "success":
            added = result.get("arguments", {}).get("torrent-added", {})
            name = added.get("name", "Unknown")
            return True, f"Added to Transmission: {name}"
        return False, f"Transmission error: {result.get('result', 'Unknown')}"
    except Exception as e:
        return False, f"Transmission error: {e}"


def format_size(bytes_val):
    try:
        gb = int(bytes_val) / 1024 / 1024 / 1024
        if gb >= 1:
            return f"{gb:.1f} GB"
        mb = int(bytes_val) / 1024 / 1024
        return f"{mb:.0f} MB"
    except (ValueError, TypeError):
        return "? GB"

def sanitize_filename(name, default="download"):
    base = Path(str(name)).name
    base = re.sub(r'[<>:"/\\|?*]', " ", base)
    base = re.sub(r"\s+", " ", base).strip().strip(". ")
    return base if base else default


def bhd_search(query, config, limit=50, resolution=None):
    """Search Beyond-HD API"""
    tracker = config["trackers"]["bhd"]
    url = f"{tracker['url']}/api/torrents/{tracker['api_key']}"

    # Append resolution to search query (like nzbcli does)
    search_query = query
    if resolution and resolution.lower() not in query.lower():
        search_query = f"{query} {resolution}"

    body = {
        "action": "search",
        "rsskey": tracker["rss_key"],
        "search": search_query,
    }

    data = json.dumps(body).encode("utf-8")

    try:
        result = request_json(
            url,
            headers={"Content-Type": "application/json"},
            data=data,
            method="POST"
        )
    except Exception as e:
        print(f"BHD API Error: {e}")
        return []

    if result.get("status_code") != 1:
        print(f"BHD Error: {result.get('status_message', 'Unknown error')}")
        return []

    results = []
    for item in result.get("results", [])[:limit]:
        results.append({
            "tracker": "BHD",
            "name": item.get("name", ""),
            "size": item.get("size", 0),
            "seeders": item.get("seeders", 0),
            "leechers": item.get("leechers", 0),
            "download_url": item.get("download_url", ""),
            "page_url": item.get("url", ""),
            "freeleech": item.get("freeleech", False),
            "internal": item.get("internal", False),
            "created_at": item.get("created_at", ""),
        })

    return results


def unit3d_search(query, config, tracker_name, limit=50, resolution=None, page=1, fetch_all=False):
    """Search UNIT3D-based tracker (Hawke, etc.)"""
    tracker = config["trackers"][tracker_name]
    base_url = tracker["url"].rstrip("/")
    results = []
    current_page = page

    while True:
        params = {
            "name": query,
            "perPage": limit,
            "page": current_page,
        }

        if resolution and resolution in UNIT3D_RESOLUTIONS:
            params["resolutions[]"] = UNIT3D_RESOLUTIONS[resolution]

        url = f"{base_url}/api/torrents/filter?{urllib.parse.urlencode(params)}"

        try:
            result = request_json(
                url,
                headers={
                    "Authorization": f"Bearer {tracker['api_key']}",
                    "Accept": "application/json",
                },
            )
        except urllib.error.HTTPError as e:
            print(f"{tracker_name.upper()} API Error: {e.code} {e.reason}")
            return []
        except Exception as e:
            print(f"{tracker_name.upper()} API Error: {e}")
            return []

        page_items = result.get("data", [])
        for item in page_items:
            attrs = item.get("attributes", item)
            results.append({
                "tracker": tracker_name.upper(),
                "id": item.get("id") or attrs.get("id"),
                "name": attrs.get("name", ""),
                "size": attrs.get("size", 0),
                "seeders": attrs.get("seeders", 0),
                "leechers": attrs.get("leechers", 0),
                "download_url": f"{base_url}/torrent/download/{item.get('id')}.{tracker['rss_key']}",
                "page_url": f"{base_url}/torrents/{item.get('id')}",
                "freeleech": attrs.get("freeleech", False) or attrs.get("free", "0%") != "0%",
                "internal": attrs.get("internal", False),
                "created_at": attrs.get("created_at", ""),
            })

        if not fetch_all:
            break
        if not page_items or len(page_items) < limit:
            break
        current_page += 1

    return results


def filelist_search(query, config, tracker_name, limit=50, resolution=None):
    """Search FileList tracker"""
    tracker = config["trackers"][tracker_name]
    base_url = tracker["url"].rstrip("/")

    # Append resolution to query if specified
    search_query = query
    if resolution and resolution.lower() not in query.lower():
        search_query = f"{query} {resolution}"

    params = {
        "username": tracker["username"],
        "passkey": tracker["passkey"],
        "action": "search-torrents",
        "type": "name",
        "query": search_query,
        "limit": limit,
    }

    url = f"{base_url}/api.php?{urllib.parse.urlencode(params)}"

    try:
        result = request_json(url)
    except urllib.error.HTTPError as e:
        print(f"FL API Error: {e.code} {e.reason}")
        return []
    except Exception as e:
        print(f"FL API Error: {e}")
        return []

    if isinstance(result, dict) and result.get("error"):
        print(f"FL Error: {result.get('error')}")
        return []

    results = []
    for item in result[:limit] if isinstance(result, list) else []:
        results.append({
            "tracker": "FL",
            "id": item.get("id"),
            "name": item.get("name", ""),
            "size": item.get("size", 0),
            "seeders": item.get("seeders", 0),
            "leechers": item.get("leechers", 0),
            "download_url": f"{base_url}/download.php?id={item.get('id')}&passkey={tracker['passkey']}",
            "page_url": f"{base_url}/details.php?id={item.get('id')}",
            "freeleech": item.get("freeleech", 0) == 1,
            "internal": item.get("internal", 0) == 1,
            "created_at": item.get("upload_date", ""),
        })

    return results


def torrentleech_login(base_url, username, password):
    """Login to TorrentLeech and get session cookies"""
    login_url = f"{base_url}/user/account/login/"

    # Disable auto-redirect to capture cookies from 302 response
    class NoRedirect(urllib.request.HTTPRedirectHandler):
        def redirect_request(self, req, fp, code, msg, hdrs, newurl):
            return None

    opener = urllib.request.build_opener(NoRedirect)

    # First, get session cookie from login page
    try:
        req = urllib.request.Request(login_url)
        req.add_header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)")
        with urllib.request.urlopen(req, timeout=30) as resp:
            cookies = resp.headers.get_all("Set-Cookie") or []
    except Exception as e:
        return None, f"Failed to get login page: {e}"

    # Extract PHPSESSID cookie
    session_cookie = ""
    for cookie in cookies:
        if "PHPSESSID" in cookie:
            session_cookie = cookie.split(";")[0]
            break

    # Submit login form
    login_data = urllib.parse.urlencode({
        "username": username,
        "password": password,
    }).encode()

    req = urllib.request.Request(login_url, data=login_data, method="POST")
    req.add_header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)")
    req.add_header("Content-Type", "application/x-www-form-urlencoded")
    req.add_header("Referer", login_url)
    if session_cookie:
        req.add_header("Cookie", session_cookie)

    try:
        opener.open(req, timeout=30)
    except urllib.error.HTTPError as e:
        # 302 redirect means success - extract all auth cookies
        if e.code == 302:
            new_cookies = e.headers.get_all("Set-Cookie") or []
            cookie_parts = []
            for cookie in new_cookies:
                part = cookie.split(";")[0]
                cookie_parts.append(part)
            session_cookie = "; ".join(cookie_parts)
        else:
            return None, f"Login failed: HTTP {e.code}"
    except Exception as e:
        return None, f"Login failed: {e}"

    # Verify we got auth cookies
    if "tluid" not in session_cookie or "tlpass" not in session_cookie:
        return None, "Login failed: Invalid credentials"

    return session_cookie, None


def torrentleech_search(query, config, tracker_name, limit=50, resolution=None):
    """Search TorrentLeech tracker via session-based JSON API"""
    tracker = config["trackers"][tracker_name]
    base_url = tracker["url"].rstrip("/")

    username = tracker.get("username")
    password = tracker.get("password")

    if not username or not password:
        print("TL Error: username and password required in config")
        return []

    # Login first
    cookies, err = torrentleech_login(base_url, username, password)
    if err:
        print(f"TL Login Error: {err}")
        return []

    # Append resolution to query if specified
    search_query = query
    if resolution and resolution.lower() not in query.lower():
        search_query = f"{query} {resolution}"

    # Use JSON API endpoint
    search_url = f"{base_url}/torrents/browse/list/query/{urllib.parse.quote(search_query)}"

    try:
        data = request_json(
            search_url,
            headers={
                "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)",
                "Cookie": cookies,
                "Accept": "application/json",
                "X-Requested-With": "XMLHttpRequest",
            },
        )
    except urllib.error.HTTPError as e:
        print(f"TL Search Error: {e.code} {e.reason}")
        return []
    except Exception as e:
        print(f"TL Search Error: {e}")
        return []

    results = []
    passkey = tracker.get("passkey", "")

    for item in data.get("torrentList", [])[:limit]:
        tid = item.get("fid", "")
        name = item.get("name", "")
        size = item.get("size", 0)
        seeders = item.get("seeders", 0)
        leechers = item.get("leechers", 0)
        tags = item.get("tags", [])

        download_url = f"{base_url}/download/{tid}/{passkey}" if passkey else f"{base_url}/download/{tid}"

        results.append({
            "tracker": "TL",
            "id": tid,
            "name": name,
            "size": size,
            "seeders": seeders,
            "leechers": leechers,
            "download_url": download_url,
            "page_url": f"{base_url}/torrent/{tid}",
            "freeleech": "FREELEECH" in tags,
            "internal": False,
            "created_at": item.get("addedTimestamp", ""),
        })

    return results


def search(args, config):
    query = args.query
    resolution = config.get("default_resolution", "1080p")

    if args.resolution:
        resolution = args.resolution
    elif args.no_default_res:
        resolution = None

    all_results = []
    unsupported_paging = []

    # Determine which trackers to search
    trackers_to_search = []
    if args.tracker:
        trackers_to_search = [args.tracker.lower()]
    else:
        trackers_to_search = list(config.get("trackers", {}).keys())

    for tracker_name in trackers_to_search:
        if tracker_name not in config.get("trackers", {}):
            print(f"Warning: Tracker '{tracker_name}' not configured")
            continue

        tracker = config["trackers"][tracker_name]
        tracker_type = tracker.get("type", "unit3d")

        if tracker_type == "bhd":
            if args.page != 1 or args.all:
                unsupported_paging.append(tracker_name)
            results = bhd_search(query, config, args.limit, resolution)
        elif tracker_type == "filelist":
            if args.page != 1 or args.all:
                unsupported_paging.append(tracker_name)
            results = filelist_search(query, config, tracker_name, args.limit, resolution)
        elif tracker_type == "torrentleech":
            if args.page != 1 or args.all:
                unsupported_paging.append(tracker_name)
            results = torrentleech_search(query, config, tracker_name, args.limit, resolution)
        else:
            results = unit3d_search(query, config, tracker_name, args.limit, resolution, args.page, args.all)

        all_results.extend(results)

    if not all_results:
        if args.json:
            print(json.dumps({
                "query": query,
                "results": [],
                "warnings": unsupported_paging,
            }, indent=2))
        else:
            print("No results found")
        return

    # Sort by seeders descending
    all_results.sort(key=lambda x: x["seeders"], reverse=True)

    if unsupported_paging and not args.json:
        warn_list = ", ".join(sorted(set(unsupported_paging)))
        print(f"Warning: paging not supported for {warn_list}")

    # If adding to torrent client, do it now
    if args.add_to_trt:
        trt_config = load_torrent_config()
        if not trt_config:
            print(f"Error: Torrent config not found at {TORRENT_CONFIG_PATH}")
            return

        # Parse which results to add (default: all, or specific numbers)
        indices = []
        if args.add_to_trt == "all" or args.add_to_trt is True:
            indices = list(range(min(len(all_results), args.limit)))
        else:
            # Parse comma-separated or space-separated numbers
            for part in args.add_to_trt.replace(",", " ").split():
                try:
                    idx = int(part) - 1  # Convert to 0-based
                    if 0 <= idx < len(all_results):
                        indices.append(idx)
                except ValueError:
                    pass

        if not indices:
            print("No valid result numbers specified")
            return

        added = 0
        added_results = []
        for idx in indices:
            item = all_results[idx]
            name = item["name"][:60]

            # TL requires session auth to download torrent files
            if item.get("tracker") == "TL":
                tl_config = config["trackers"].get("tl", {})
                torrent_data, err = download_tl_torrent(item["download_url"], tl_config)
                if err:
                    print(f"Failed: {name} - {err}")
                    continue
                success, msg = add_to_torrent_client(None, trt_config, torrent_data=torrent_data)
            else:
                success, msg = add_to_torrent_client(item["download_url"], trt_config)

            if success:
                if not args.json:
                    print(f"Added: {name}")
                added += 1
            else:
                if not args.json:
                    print(f"Failed: {name} - {msg}")

            added_results.append({
                "name": item["name"],
                "success": success,
                "message": msg,
            })

        if args.json:
            print(json.dumps({
                "query": query,
                "results": all_results,
                "added": added_results,
                "warnings": unsupported_paging,
            }, indent=2))
        else:
            print(f"\nAdded {added}/{len(indices)} torrents")
        return

    if args.json:
        print(json.dumps({
            "query": query,
            "results": all_results,
            "warnings": unsupported_paging,
        }, indent=2))
        return

    # Print results
    print(f"\n{'#':<3} {'Tracker':<6} {'Name':<65} {'Size':>8} {'S':>4} {'L':>4}")
    print("-" * 95)

    for i, item in enumerate(all_results[:args.limit], 1):
        name = item["name"][:64]
        size = format_size(item["size"])
        flags = ""
        if item.get("freeleech"):
            flags += " [FL]"
        if item.get("internal"):
            flags += " [INT]"

        print(f"{i:<3} {item['tracker']:<6} {name:<65} {size:>8} {item['seeders']:>4} {item['leechers']:>4}{flags}")

    if args.show_urls:
        print("\nDownload URLs:")
        for i, item in enumerate(all_results[:args.limit], 1):
            print(f"  {i}: {item['download_url']}")


def get(args, config):
    """Download a torrent file or add directly to torrent client"""
    url = args.url_or_num

    # If adding directly to torrent client, skip download
    if args.add_to_trt:
        trt_config = load_torrent_config()
        if not trt_config:
            print(f"Error: Torrent config not found at {TORRENT_CONFIG_PATH}")
            sys.exit(1)

        success, msg = add_to_torrent_client(url, trt_config)
        if args.json:
            print(json.dumps({
                "success": success,
                "message": msg,
            }, indent=2))
        elif success:
            print(msg)
        else:
            print(f"Failed: {msg}")
        if not success:
            sys.exit(1)
        return

    # Download torrent file
    output_dir = Path(args.output or config.get("default_download_path", "."))
    output_dir.mkdir(parents=True, exist_ok=True)

    # Determine tracker from URL for auth headers
    headers = {}
    for tracker_name, tracker in config.get("trackers", {}).items():
        tracker_url = tracker.get("url", "")
        if tracker_url and tracker_url in url:
            if tracker.get("type") == "unit3d" and tracker.get("api_key"):
                headers["Authorization"] = f"Bearer {tracker['api_key']}"
            break

    try:
        content, resp_headers = request_bytes(url, headers=headers)

        # Try to get filename from Content-Disposition
        cd = resp_headers.get("Content-Disposition", "")
        filename = None
        if "filename=" in cd:
            match = re.search(r'filename[*]?=["\']?([^"\';\n]+)', cd)
            if match:
                filename = match.group(1).strip()

        if not filename:
            filename = "download.torrent"
        filename = sanitize_filename(filename)
        if not filename.lower().endswith(".torrent"):
            filename = f"{filename}.torrent"

        output_path = output_dir / filename
        with open(output_path, "wb") as f:
            f.write(content)

        size = output_path.stat().st_size / 1024
        if args.json:
            print(json.dumps({
                "filename": filename,
                "size_kb": round(size, 1),
                "path": str(output_path),
            }, indent=2))
        else:
            print(f"Downloaded: {filename}")
            print(f"Size: {size:.1f} KB")
            print(f"Path: {output_path}")

    except Exception as e:
        print(f"Download error: {e}")
        sys.exit(1)


def recent(args, config):
    """Show recent uploads from trackers"""
    resolution = config.get("default_resolution", "1080p")
    if args.no_default_res:
        resolution = None

    all_results = []
    unsupported_paging = []

    trackers_to_search = []
    if args.tracker:
        trackers_to_search = [args.tracker.lower()]
    else:
        trackers_to_search = list(config.get("trackers", {}).keys())

    for tracker_name in trackers_to_search:
        if tracker_name not in config.get("trackers", {}):
            continue

        tracker = config["trackers"][tracker_name]
        tracker_type = tracker.get("type", "unit3d")

        # Use empty query for recent
        if tracker_type == "bhd":
            if args.page != 1 or args.all:
                unsupported_paging.append(tracker_name)
            results = bhd_search("", config, args.limit, resolution)
        elif tracker_type == "filelist":
            if args.page != 1 or args.all:
                unsupported_paging.append(tracker_name)
            results = filelist_search("", config, tracker_name, args.limit, resolution)
        elif tracker_type == "torrentleech":
            if args.page != 1 or args.all:
                unsupported_paging.append(tracker_name)
            results = torrentleech_search("", config, tracker_name, args.limit, resolution)
        else:
            results = unit3d_search("", config, tracker_name, args.limit, resolution, args.page, args.all)

        all_results.extend(results)

    if not all_results:
        if args.json:
            print(json.dumps({
                "results": [],
                "warnings": unsupported_paging,
            }, indent=2))
        else:
            print("No results found")
        return

    # Sort by date descending (most recent first)
    all_results.sort(key=lambda x: x.get("created_at", ""), reverse=True)

    if unsupported_paging and not args.json:
        warn_list = ", ".join(sorted(set(unsupported_paging)))
        print(f"Warning: paging not supported for {warn_list}")

    # If adding to torrent client
    if hasattr(args, 'add_to_trt') and args.add_to_trt:
        trt_config = load_torrent_config()
        if not trt_config:
            print(f"Error: Torrent config not found at {TORRENT_CONFIG_PATH}")
            return

        indices = []
        if args.add_to_trt == "all" or args.add_to_trt is True:
            indices = list(range(min(len(all_results), args.limit)))
        else:
            for part in args.add_to_trt.replace(",", " ").split():
                try:
                    idx = int(part) - 1
                    if 0 <= idx < len(all_results):
                        indices.append(idx)
                except ValueError:
                    pass

        if not indices:
            print("No valid result numbers specified")
            return

        added = 0
        added_results = []
        for idx in indices:
            item = all_results[idx]
            name = item["name"][:60]

            # TL requires session auth to download torrent files
            if item.get("tracker") == "TL":
                tl_config = config["trackers"].get("tl", {})
                torrent_data, err = download_tl_torrent(item["download_url"], tl_config)
                if err:
                    print(f"Failed: {name} - {err}")
                    continue
                success, msg = add_to_torrent_client(None, trt_config, torrent_data=torrent_data)
            else:
                success, msg = add_to_torrent_client(item["download_url"], trt_config)

            if success:
                if not args.json:
                    print(f"Added: {name}")
                added += 1
            else:
                if not args.json:
                    print(f"Failed: {name} - {msg}")

            added_results.append({
                "name": item["name"],
                "success": success,
                "message": msg,
            })

        if args.json:
            print(json.dumps({
                "results": all_results,
                "added": added_results,
                "warnings": unsupported_paging,
            }, indent=2))
        else:
            print(f"\nAdded {added}/{len(indices)} torrents")
        return

    if args.json:
        print(json.dumps({
            "results": all_results,
            "warnings": unsupported_paging,
        }, indent=2))
        return

    print(f"\n{'#':<3} {'Tracker':<6} {'Name':<65} {'Size':>8} {'S':>4}")
    print("-" * 90)

    for i, item in enumerate(all_results[:args.limit], 1):
        name = item["name"][:64]
        size = format_size(item["size"])
        flags = ""
        if item.get("freeleech"):
            flags += " [FL]"

        print(f"{i:<3} {item['tracker']:<6} {name:<65} {size:>8} {item['seeders']:>4}{flags}")


def main():
    parser = argparse.ArgumentParser(
        description="Tracker CLI - Search private trackers",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  tk search "Oppenheimer"              # Search all trackers (1080p default)
  tk search "Oppenheimer" -t bhd       # Search Beyond-HD only
  tk search "Oppenheimer" -t fl        # Search FileList only
  tk search "Oppenheimer" -t tl        # Search TorrentLeech only
  tk search "Oppenheimer" -T           # Search and add all to torrent client
  tk search "Oppenheimer" -T 1,2,3     # Add specific results
  tk recent -t hawke                   # Recent from Hawke

Trackers: bhd, hawke, fnp (UNIT3D), fl (FileList), tl (TorrentLeech)
Config: ~/.config/trackers/config.json
        """
    )

    parser.add_argument("-j", "--json", action="store_true", help="JSON output")

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Search command
    search_p = subparsers.add_parser("search", aliases=["s"], help="Search trackers")
    search_p.add_argument("query", help="Search query")
    search_p.add_argument("-t", "--tracker", help="Specific tracker (bhd, hawke)")
    search_p.add_argument("-r", "--resolution", help="Resolution filter (1080p, 2160p, 720p)")
    search_p.add_argument("-l", "--limit", type=int, default=25, help="Max results (default: 25)")
    search_p.add_argument("--page", type=int, default=1, help="Page number (UNIT3D only)")
    search_p.add_argument("--all", action="store_true", help="Fetch all pages (UNIT3D only)")
    search_p.add_argument("--no-default-res", action="store_true", help="Don't apply default resolution filter")
    search_p.add_argument("--show-urls", action="store_true", help="Show download URLs")
    search_p.add_argument("-T", "--add-to-trt", nargs="?", const="all", help="Add to torrent client (all or specific #s: 1,2,3)")

    # Get/download command
    get_p = subparsers.add_parser("get", aliases=["g", "download", "d"], help="Download torrent")
    get_p.add_argument("url_or_num", help="Download URL")
    get_p.add_argument("-o", "--output", help="Output directory")
    get_p.add_argument("-T", "--add-to-trt", action="store_true", help="Add directly to torrent client")

    # Recent command
    recent_p = subparsers.add_parser("recent", aliases=["r"], help="Recent uploads")
    recent_p.add_argument("-t", "--tracker", help="Specific tracker")
    recent_p.add_argument("-l", "--limit", type=int, default=25, help="Max results (default: 25)")
    recent_p.add_argument("--page", type=int, default=1, help="Page number (UNIT3D only)")
    recent_p.add_argument("--all", action="store_true", help="Fetch all pages (UNIT3D only)")
    recent_p.add_argument("--no-default-res", action="store_true", help="Don't filter by default resolution")
    recent_p.add_argument("-T", "--add-to-trt", nargs="?", const="all", help="Add to torrent client (all or specific #s: 1,2,3)")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    config = load_config()

    if args.command in ("search", "s"):
        search(args, config)
    elif args.command in ("get", "g", "download", "d"):
        get(args, config)
    elif args.command in ("recent", "r"):
        recent(args, config)


if __name__ == "__main__":
    main()
