#!/usr/bin/env python3
"""
Tracker CLI - Search and download torrents from private trackers
Supports: Beyond-HD, Hawke.uno (UNIT3D)
"""

import argparse
import json
import sys
import urllib.request
import urllib.parse
from pathlib import Path

CONFIG_PATH = Path.home() / ".config" / "trackers" / "config.json"
TORRENT_CONFIG_PATH = Path.home() / ".config" / "torrent" / "config.json"

# Resolution mappings for UNIT3D trackers
UNIT3D_RESOLUTIONS = {
    "2160p": "2",
    "4k": "2",
    "1080p": "3",
    "720p": "5",
}

def load_config():
    if not CONFIG_PATH.exists():
        print(f"Error: Config file not found at {CONFIG_PATH}")
        print("Create it with tracker configs. See --help for format.")
        sys.exit(1)
    with open(CONFIG_PATH) as f:
        return json.load(f)


def load_torrent_config():
    """Load torrent client config for trtcli integration"""
    if not TORRENT_CONFIG_PATH.exists():
        return None
    with open(TORRENT_CONFIG_PATH) as f:
        return json.load(f)


def add_to_torrent_client(url, trt_config):
    """Add torrent URL to configured torrent client (Transmission or qBittorrent)"""
    import base64

    client = trt_config.get("client", "transmission").lower()

    if client == "qbittorrent":
        return add_to_qbittorrent(url, trt_config)
    else:
        return add_to_transmission_url(url, trt_config)


def add_to_qbittorrent(url, config):
    """Add torrent URL to qBittorrent"""
    base_url = config["url"].rstrip("/")
    username = config.get("username", "")
    password = config.get("password", "")

    # Login first
    login_data = urllib.parse.urlencode({
        "username": username,
        "password": password
    }).encode()

    cookie = None
    try:
        req = urllib.request.Request(f"{base_url}/api/v2/auth/login", data=login_data)
        with urllib.request.urlopen(req, timeout=10) as resp:
            cookie = resp.headers.get("Set-Cookie", "").split(";")[0]
    except Exception as e:
        return False, f"qBittorrent login failed: {e}"

    # Add torrent
    add_data = urllib.parse.urlencode({"urls": url}).encode()
    headers = {"Cookie": cookie} if cookie else {}

    try:
        req = urllib.request.Request(f"{base_url}/api/v2/torrents/add", data=add_data, headers=headers)
        with urllib.request.urlopen(req, timeout=30) as resp:
            result = resp.read().decode()
            if result == "Ok." or resp.status == 200:
                return True, "Added to qBittorrent"
            return False, f"qBittorrent error: {result}"
    except Exception as e:
        return False, f"qBittorrent error: {e}"


def add_to_transmission_url(url, config):
    """Add torrent URL to Transmission"""
    import base64

    rpc_url = config["url"]
    auth_header = None
    if config.get("username") and config.get("password"):
        creds = f"{config['username']}:{config['password']}"
        auth_header = "Basic " + base64.b64encode(creds.encode()).decode()

    headers = {"Content-Type": "application/json"}
    if auth_header:
        headers["Authorization"] = auth_header

    # Get session ID
    session_id = None
    try:
        req = urllib.request.Request(rpc_url, headers=headers, method="POST", data=b"{}")
        urllib.request.urlopen(req, timeout=10)
    except urllib.error.HTTPError as e:
        if e.code == 409:
            session_id = e.headers.get("X-Transmission-Session-Id")
        else:
            return False, f"Transmission error: {e}"

    if session_id:
        headers["X-Transmission-Session-Id"] = session_id

    body = json.dumps({
        "method": "torrent-add",
        "arguments": {"filename": url}
    }).encode()

    try:
        req = urllib.request.Request(rpc_url, headers=headers, method="POST", data=body)
        with urllib.request.urlopen(req, timeout=30) as resp:
            result = json.loads(resp.read().decode())
            if result.get("result") == "success":
                added = result.get("arguments", {}).get("torrent-added", {})
                name = added.get("name", "Unknown")
                return True, f"Added to Transmission: {name}"
            else:
                return False, f"Transmission error: {result.get('result', 'Unknown')}"
    except Exception as e:
        return False, f"Transmission error: {e}"


def format_size(bytes_val):
    try:
        gb = int(bytes_val) / 1024 / 1024 / 1024
        if gb >= 1:
            return f"{gb:.1f} GB"
        mb = int(bytes_val) / 1024 / 1024
        return f"{mb:.0f} MB"
    except (ValueError, TypeError):
        return "? GB"


def bhd_search(query, config, limit=50, resolution=None):
    """Search Beyond-HD API"""
    tracker = config["trackers"]["bhd"]
    url = f"{tracker['url']}/api/torrents/{tracker['api_key']}"

    # Append resolution to search query (like nzbcli does)
    search_query = query
    if resolution and resolution.lower() not in query.lower():
        search_query = f"{query} {resolution}"

    body = {
        "action": "search",
        "rsskey": tracker["rss_key"],
        "search": search_query,
    }

    data = json.dumps(body).encode("utf-8")
    req = urllib.request.Request(
        url,
        data=data,
        headers={"Content-Type": "application/json"},
        method="POST"
    )

    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            result = json.loads(resp.read().decode())
    except Exception as e:
        print(f"BHD API Error: {e}")
        return []

    if result.get("status_code") != 1:
        print(f"BHD Error: {result.get('status_message', 'Unknown error')}")
        return []

    results = []
    for item in result.get("results", [])[:limit]:
        results.append({
            "tracker": "BHD",
            "name": item.get("name", ""),
            "size": item.get("size", 0),
            "seeders": item.get("seeders", 0),
            "leechers": item.get("leechers", 0),
            "download_url": item.get("download_url", ""),
            "page_url": item.get("url", ""),
            "freeleech": item.get("freeleech", False),
            "internal": item.get("internal", False),
            "created_at": item.get("created_at", ""),
        })

    return results


def unit3d_search(query, config, tracker_name, limit=50, resolution=None):
    """Search UNIT3D-based tracker (Hawke, etc.)"""
    tracker = config["trackers"][tracker_name]
    base_url = tracker["url"].rstrip("/")

    params = {
        "name": query,
        "perPage": limit,
    }

    if resolution and resolution in UNIT3D_RESOLUTIONS:
        params["resolutions[]"] = UNIT3D_RESOLUTIONS[resolution]

    url = f"{base_url}/api/torrents/filter?{urllib.parse.urlencode(params)}"

    req = urllib.request.Request(
        url,
        headers={
            "Authorization": f"Bearer {tracker['api_key']}",
            "Accept": "application/json",
        },
        method="GET"
    )

    try:
        with urllib.request.urlopen(req, timeout=30) as resp:
            result = json.loads(resp.read().decode())
    except urllib.error.HTTPError as e:
        print(f"{tracker_name.upper()} API Error: {e.code} {e.reason}")
        return []
    except Exception as e:
        print(f"{tracker_name.upper()} API Error: {e}")
        return []

    results = []
    for item in result.get("data", []):
        attrs = item.get("attributes", item)
        results.append({
            "tracker": tracker_name.upper(),
            "id": item.get("id") or attrs.get("id"),
            "name": attrs.get("name", ""),
            "size": attrs.get("size", 0),
            "seeders": attrs.get("seeders", 0),
            "leechers": attrs.get("leechers", 0),
            "download_url": f"{base_url}/torrent/download/{item.get('id')}.{tracker['rss_key']}",
            "page_url": f"{base_url}/torrents/{item.get('id')}",
            "freeleech": attrs.get("freeleech", False) or attrs.get("free", "0%") != "0%",
            "internal": attrs.get("internal", False),
            "created_at": attrs.get("created_at", ""),
        })

    return results


def search(args, config):
    query = args.query
    resolution = config.get("default_resolution", "1080p")

    if args.resolution:
        resolution = args.resolution
    elif args.no_default_res:
        resolution = None

    all_results = []

    # Determine which trackers to search
    trackers_to_search = []
    if args.tracker:
        trackers_to_search = [args.tracker.lower()]
    else:
        trackers_to_search = list(config.get("trackers", {}).keys())

    for tracker_name in trackers_to_search:
        if tracker_name not in config.get("trackers", {}):
            print(f"Warning: Tracker '{tracker_name}' not configured")
            continue

        tracker = config["trackers"][tracker_name]
        tracker_type = tracker.get("type", "unit3d")

        if tracker_type == "bhd":
            results = bhd_search(query, config, args.limit, resolution)
        else:
            results = unit3d_search(query, config, tracker_name, args.limit, resolution)

        all_results.extend(results)

    if not all_results:
        print("No results found")
        return

    # Sort by seeders descending
    all_results.sort(key=lambda x: x["seeders"], reverse=True)

    # If adding to torrent client, do it now
    if args.add_to_trt:
        trt_config = load_torrent_config()
        if not trt_config:
            print(f"Error: Torrent config not found at {TORRENT_CONFIG_PATH}")
            return

        # Parse which results to add (default: all, or specific numbers)
        indices = []
        if args.add_to_trt == "all" or args.add_to_trt is True:
            indices = list(range(min(len(all_results), args.limit)))
        else:
            # Parse comma-separated or space-separated numbers
            for part in args.add_to_trt.replace(",", " ").split():
                try:
                    idx = int(part) - 1  # Convert to 0-based
                    if 0 <= idx < len(all_results):
                        indices.append(idx)
                except ValueError:
                    pass

        if not indices:
            print("No valid result numbers specified")
            return

        added = 0
        for idx in indices:
            item = all_results[idx]
            success, msg = add_to_torrent_client(item["download_url"], trt_config)
            name = item["name"][:60]
            if success:
                print(f"Added: {name}")
                added += 1
            else:
                print(f"Failed: {name} - {msg}")

        print(f"\nAdded {added}/{len(indices)} torrents")
        return

    # Print results
    print(f"\n{'#':<3} {'Tracker':<6} {'Name':<65} {'Size':>8} {'S':>4} {'L':>4}")
    print("-" * 95)

    for i, item in enumerate(all_results[:args.limit], 1):
        name = item["name"][:64]
        size = format_size(item["size"])
        flags = ""
        if item.get("freeleech"):
            flags += " [FL]"
        if item.get("internal"):
            flags += " [INT]"

        print(f"{i:<3} {item['tracker']:<6} {name:<65} {size:>8} {item['seeders']:>4} {item['leechers']:>4}{flags}")

    if args.show_urls:
        print("\nDownload URLs:")
        for i, item in enumerate(all_results[:args.limit], 1):
            print(f"  {i}: {item['download_url']}")


def get(args, config):
    """Download a torrent file or add directly to torrent client"""
    url = args.url_or_num

    # If adding directly to torrent client, skip download
    if args.add_to_trt:
        trt_config = load_torrent_config()
        if not trt_config:
            print(f"Error: Torrent config not found at {TORRENT_CONFIG_PATH}")
            sys.exit(1)

        success, msg = add_to_torrent_client(url, trt_config)
        if success:
            print(msg)
        else:
            print(f"Failed: {msg}")
            sys.exit(1)
        return

    # Download torrent file
    output_dir = Path(args.output or config.get("default_download_path", "."))
    output_dir.mkdir(parents=True, exist_ok=True)

    # Determine tracker from URL for auth headers
    headers = {}
    for tracker_name, tracker in config.get("trackers", {}).items():
        if tracker["url"] in url:
            if tracker.get("type") != "bhd":
                headers["Authorization"] = f"Bearer {tracker['api_key']}"
            break

    try:
        req = urllib.request.Request(url, headers=headers)
        with urllib.request.urlopen(req, timeout=30) as resp:
            content = resp.read()

            # Try to get filename from Content-Disposition
            cd = resp.headers.get("Content-Disposition", "")
            filename = None
            if "filename=" in cd:
                import re
                match = re.search(r'filename[*]?=["\']?([^"\';\n]+)', cd)
                if match:
                    filename = match.group(1).strip()

            if not filename:
                filename = "download.torrent"

            output_path = output_dir / filename
            with open(output_path, "wb") as f:
                f.write(content)

            size = output_path.stat().st_size / 1024
            print(f"Downloaded: {filename}")
            print(f"Size: {size:.1f} KB")
            print(f"Path: {output_path}")

    except Exception as e:
        print(f"Download error: {e}")
        sys.exit(1)


def recent(args, config):
    """Show recent uploads from trackers"""
    resolution = config.get("default_resolution", "1080p")
    if args.no_default_res:
        resolution = None

    all_results = []

    trackers_to_search = []
    if args.tracker:
        trackers_to_search = [args.tracker.lower()]
    else:
        trackers_to_search = list(config.get("trackers", {}).keys())

    for tracker_name in trackers_to_search:
        if tracker_name not in config.get("trackers", {}):
            continue

        tracker = config["trackers"][tracker_name]
        tracker_type = tracker.get("type", "unit3d")

        # Use empty query for recent
        if tracker_type == "bhd":
            results = bhd_search("", config, args.limit, resolution)
        else:
            results = unit3d_search("", config, tracker_name, args.limit, resolution)

        all_results.extend(results)

    if not all_results:
        print("No results found")
        return

    # Sort by date descending (most recent first)
    all_results.sort(key=lambda x: x.get("created_at", ""), reverse=True)

    # If adding to torrent client
    if hasattr(args, 'add_to_trt') and args.add_to_trt:
        trt_config = load_torrent_config()
        if not trt_config:
            print(f"Error: Torrent config not found at {TORRENT_CONFIG_PATH}")
            return

        indices = []
        if args.add_to_trt == "all" or args.add_to_trt is True:
            indices = list(range(min(len(all_results), args.limit)))
        else:
            for part in args.add_to_trt.replace(",", " ").split():
                try:
                    idx = int(part) - 1
                    if 0 <= idx < len(all_results):
                        indices.append(idx)
                except ValueError:
                    pass

        if not indices:
            print("No valid result numbers specified")
            return

        added = 0
        for idx in indices:
            item = all_results[idx]
            success, msg = add_to_torrent_client(item["download_url"], trt_config)
            name = item["name"][:60]
            if success:
                print(f"Added: {name}")
                added += 1
            else:
                print(f"Failed: {name} - {msg}")

        print(f"\nAdded {added}/{len(indices)} torrents")
        return

    print(f"\n{'#':<3} {'Tracker':<6} {'Name':<65} {'Size':>8} {'S':>4}")
    print("-" * 90)

    for i, item in enumerate(all_results[:args.limit], 1):
        name = item["name"][:64]
        size = format_size(item["size"])
        flags = ""
        if item.get("freeleech"):
            flags += " [FL]"

        print(f"{i:<3} {item['tracker']:<6} {name:<65} {size:>8} {item['seeders']:>4}{flags}")


def main():
    parser = argparse.ArgumentParser(
        description="Tracker CLI - Search private trackers",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  tk search "Oppenheimer"              # Search all trackers (1080p default)
  tk search "Oppenheimer" -t bhd       # Search Beyond-HD only
  tk search "Oppenheimer" -t hawke     # Search Hawke only
  tk search "Oppenheimer" -r 2160p     # Search for 4K
  tk search "Oppenheimer" -T           # Search and add all to torrent client
  tk search "Oppenheimer" -T 1,2,3     # Add specific results to torrent client
  tk get <url> -T                      # Add URL directly to torrent client
  tk recent -T 1                       # Add first recent upload
  tk recent -t bhd                     # Recent from Beyond-HD

Trackers: bhd (Beyond-HD), hawke (Hawke.uno)
Default: 1080p resolution filter applied

Torrent client config: ~/.config/torrent/config.json
Tracker config: ~/.config/trackers/config.json
{
  "default_resolution": "1080p",
  "default_download_path": "~/Downloads/torrents",
  "trackers": {
    "bhd": {
      "type": "bhd",
      "url": "https://beyond-hd.me",
      "api_key": "your-api-key",
      "rss_key": "your-rss-key"
    },
    "hawke": {
      "type": "unit3d",
      "url": "https://hawke.uno",
      "api_key": "your-api-token",
      "rss_key": "your-rss-key"
    }
  }
}
        """
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Search command
    search_p = subparsers.add_parser("search", aliases=["s"], help="Search trackers")
    search_p.add_argument("query", help="Search query")
    search_p.add_argument("-t", "--tracker", help="Specific tracker (bhd, hawke)")
    search_p.add_argument("-r", "--resolution", help="Resolution filter (1080p, 2160p, 720p)")
    search_p.add_argument("-l", "--limit", type=int, default=25, help="Max results (default: 25)")
    search_p.add_argument("--no-default-res", action="store_true", help="Don't apply default resolution filter")
    search_p.add_argument("--show-urls", action="store_true", help="Show download URLs")
    search_p.add_argument("-T", "--add-to-trt", nargs="?", const="all", help="Add to torrent client (all or specific #s: 1,2,3)")

    # Get/download command
    get_p = subparsers.add_parser("get", aliases=["g", "download", "d"], help="Download torrent")
    get_p.add_argument("url_or_num", help="Download URL")
    get_p.add_argument("-o", "--output", help="Output directory")
    get_p.add_argument("-T", "--add-to-trt", action="store_true", help="Add directly to torrent client")

    # Recent command
    recent_p = subparsers.add_parser("recent", aliases=["r"], help="Recent uploads")
    recent_p.add_argument("-t", "--tracker", help="Specific tracker")
    recent_p.add_argument("-l", "--limit", type=int, default=25, help="Max results (default: 25)")
    recent_p.add_argument("--no-default-res", action="store_true", help="Don't filter by default resolution")
    recent_p.add_argument("-T", "--add-to-trt", nargs="?", const="all", help="Add to torrent client (all or specific #s: 1,2,3)")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    config = load_config()

    if args.command in ("search", "s"):
        search(args, config)
    elif args.command in ("get", "g", "download", "d"):
        get(args, config)
    elif args.command in ("recent", "r"):
        recent(args, config)


if __name__ == "__main__":
    main()
