#!/usr/bin/env python3
"""
FoodCLI - Search and fetch nutrition data from USDA FoodData Central and Open Food Facts
"""

import argparse
import json
import os
import sys
import time
import urllib.request
import urllib.parse
import urllib.error
from pathlib import Path

CONFIG_PATH = Path(os.environ.get(
    "FOODCLI_CONFIG_PATH",
    str(Path.home() / ".config" / "foodcli" / "config.json")
))
VERSION = "1.1.1"
USER_AGENT = f"FoodCLI/{VERSION} (+https://github.com/copey02/homebrew-tap)"

USDA_API_BASE = "https://api.nal.usda.gov/fdc/v1"
OFF_API_BASE = "https://world.openfoodfacts.org"

# Key nutrients to display (USDA nutrient number -> display name)
KEY_NUTRIENTS = {
    "208": "Calories",
    "203": "Protein",
    "204": "Total Fat",
    "205": "Carbohydrates",
    "291": "Fiber",
    "269": "Sugars",
    "307": "Sodium",
    "301": "Calcium",
    "303": "Iron",
    "306": "Potassium",
    "401": "Vitamin C",
    "323": "Vitamin E",
    "328": "Vitamin D",
    "606": "Saturated Fat",
    "601": "Cholesterol",
}


def load_config():
    config = {}
    if CONFIG_PATH.exists():
        try:
            with open(CONFIG_PATH) as f:
                config = json.load(f)
        except json.JSONDecodeError:
            print(f"Error: invalid JSON in {CONFIG_PATH}", file=sys.stderr)
            sys.exit(1)
        except OSError as e:
            print(f"Error reading config: {e}", file=sys.stderr)
            sys.exit(1)

    env_key = os.getenv("FOODCLI_USDA_API_KEY") or os.getenv("FOODCLI_API_KEY")
    if env_key:
        config["api_key"] = env_key

    return config


def http_request(url, data=None, headers=None, method=None, retries=3):
    """Make HTTP request and return JSON response."""
    headers = headers or {}
    headers.setdefault("User-Agent", USER_AGENT)

    payload = None
    if data is not None:
        payload = json.dumps(data).encode()
        headers.setdefault("Content-Type", "application/json")

    req = urllib.request.Request(
        url,
        data=payload,
        headers=headers,
        method=method or ("POST" if payload is not None else "GET")
    )

    for attempt in range(retries):
        try:
            with urllib.request.urlopen(req, timeout=30) as resp:
                return json.loads(resp.read().decode())
        except urllib.error.HTTPError as e:
            if e.code in {429, 500, 502, 503, 504} and attempt < retries - 1:
                retry_after = e.headers.get("Retry-After")
                backoff = int(retry_after) if retry_after and retry_after.isdigit() else 2 ** attempt
                time.sleep(backoff)
                continue
            error_body = e.read().decode() if e.fp else str(e)
            print(f"Error: API returned {e.code}", file=sys.stderr)
            print(error_body[:500], file=sys.stderr)
            sys.exit(1)
        except urllib.error.URLError as e:
            if attempt < retries - 1:
                time.sleep(2 ** attempt)
                continue
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)


# =============================================================================
# USDA FoodData Central
# =============================================================================

def usda_search(args):
    """Search USDA FoodData Central"""
    config = load_config()
    if not config.get("api_key"):
        print(f"Error: USDA requires api_key in {CONFIG_PATH}", file=sys.stderr)
        print("You can also set FOODCLI_USDA_API_KEY.", file=sys.stderr)
        print("Get free key at: https://fdc.nal.usda.gov/api-key-signup.html", file=sys.stderr)
        sys.exit(1)

    params = {
        "query": args.query,
        "pageSize": args.limit,
    }

    if args.type:
        type_map = {
            "branded": "Branded",
            "foundation": "Foundation",
            "survey": "Survey (FNDDS)",
            "legacy": "SR Legacy"
        }
        params["dataType"] = [type_map.get(args.type, args.type)]

    if args.brand:
        params["brandOwner"] = args.brand

    url = f"{USDA_API_BASE}/foods/search?api_key={config['api_key']}"

    results = []
    page = args.page
    total_hits = 0
    total_pages = 1

    while True:
        params["pageNumber"] = page
        data = http_request(url, data=params)
        total_hits = data.get("totalHits", total_hits)
        total_pages = data.get("totalPages", total_pages)

        for food in data.get("foods", []):
            item = {
                "id": food.get("fdcId"),
                "description": food.get("description"),
                "dataType": food.get("dataType"),
                "brand": food.get("brandOwner") or food.get("brandName"),
                "servingSize": food.get("servingSize"),
                "servingSizeUnit": food.get("servingSizeUnit"),
            }
            if food.get("foodNutrients"):
                item["nutrients"] = extract_usda_nutrients(food["foodNutrients"])
            results.append(item)

        if not args.all or page >= total_pages:
            break
        page += 1

    return {
        "source": "usda",
        "query": args.query,
        "totalHits": total_hits,
        "currentPage": args.page,
        "totalPages": total_pages,
        "foods": results
    }


def usda_info(food_id, include_all=False):
    """Get USDA food details"""
    config = load_config()
    if not config.get("api_key"):
        print(f"Error: USDA requires api_key in {CONFIG_PATH}", file=sys.stderr)
        print("You can also set FOODCLI_USDA_API_KEY.", file=sys.stderr)
        sys.exit(1)

    url = f"{USDA_API_BASE}/food/{food_id}?api_key={config['api_key']}&format=full"
    data = http_request(url)

    return {
        "source": "usda",
        "id": data.get("fdcId"),
        "description": data.get("description"),
        "dataType": data.get("dataType"),
        "brand": data.get("brandOwner") or data.get("brandName"),
        "ingredients": data.get("ingredients"),
        "servingSize": data.get("servingSize"),
        "servingSizeUnit": data.get("servingSizeUnit"),
        "servingDescription": data.get("householdServingFullText"),
        "nutrients": extract_usda_nutrients(data.get("foodNutrients", []), include_all)
    }


def extract_usda_nutrients(food_nutrients, include_all=False):
    """Extract nutrients from USDA API response"""
    nutrients = {}
    for n in food_nutrients:
        if "nutrient" in n:
            num = str(n["nutrient"].get("number", ""))
            name = n["nutrient"].get("name", "")
            unit = n["nutrient"].get("unitName", "")
            amount = n.get("amount", 0)
        else:
            num = str(n.get("nutrientNumber", ""))
            name = n.get("nutrientName", "")
            unit = n.get("unitName", "")
            amount = n.get("value", 0)

        if include_all or num in KEY_NUTRIENTS:
            display_name = KEY_NUTRIENTS.get(num, name)
            nutrients[display_name] = {
                "amount": round(amount, 2) if amount else 0,
                "unit": unit
            }
    return nutrients


# =============================================================================
# Open Food Facts
# =============================================================================

def off_search(args):
    """Search Open Food Facts"""
    params = {
        "search_terms": args.query,
        "page_size": args.limit,
        "page": args.page,
        "json": 1,
    }
    results = []
    page = args.page
    total_hits = 0
    total_pages = 1

    while True:
        params["page"] = page
        url = f"{OFF_API_BASE}/cgi/search.pl?{urllib.parse.urlencode(params)}"
        data = http_request(url)

        total_hits = data.get("count", total_hits)
        total_pages = data.get("page_count", total_pages)

        for product in data.get("products", []):
            nutrients = extract_off_nutrients(product.get("nutriments", {}))
            item = {
                "id": product.get("code"),
                "description": product.get("product_name") or product.get("product_name_en") or "Unknown",
                "dataType": "OpenFoodFacts",
                "brand": product.get("brands"),
                "servingSize": product.get("serving_size"),
                "nutrients": nutrients,
            }
            results.append(item)

        if not args.all or page >= total_pages:
            break
        page += 1

    return {
        "source": "off",
        "query": args.query,
        "totalHits": total_hits,
        "currentPage": args.page,
        "totalPages": total_pages,
        "foods": results
    }


def off_info(barcode, include_all=False):
    """Get Open Food Facts product details by barcode"""
    url = f"{OFF_API_BASE}/api/v2/product/{barcode}"
    data = http_request(url)

    if data.get("status") == 0:
        print(f"Error: Product {barcode} not found", file=sys.stderr)
        sys.exit(1)

    product = data.get("product", {})
    return {
        "source": "off",
        "id": product.get("code"),
        "description": product.get("product_name") or product.get("product_name_en"),
        "dataType": "OpenFoodFacts",
        "brand": product.get("brands"),
        "ingredients": product.get("ingredients_text") or product.get("ingredients_text_en"),
        "servingSize": product.get("serving_size"),
        "servingDescription": product.get("serving_quantity"),
        "nutrients": extract_off_nutrients(product.get("nutriments", {}), include_all)
    }


def extract_off_nutrients(nutriments, include_all=False):
    """Extract nutrients from Open Food Facts nutriments object"""
    # Map OFF keys to our standard names (values are per 100g)
    mapping = {
        "energy-kcal_100g": ("Calories", "kcal"),
        "proteins_100g": ("Protein", "g"),
        "fat_100g": ("Total Fat", "g"),
        "carbohydrates_100g": ("Carbohydrates", "g"),
        "fiber_100g": ("Fiber", "g"),
        "sugars_100g": ("Sugars", "g"),
        "sodium_100g": ("Sodium", "g"),
        "calcium_100g": ("Calcium", "mg"),
        "iron_100g": ("Iron", "mg"),
        "potassium_100g": ("Potassium", "mg"),
        "vitamin-c_100g": ("Vitamin C", "mg"),
        "vitamin-e_100g": ("Vitamin E", "mg"),
        "vitamin-d_100g": ("Vitamin D", "Âµg"),
        "saturated-fat_100g": ("Saturated Fat", "g"),
        "cholesterol_100g": ("Cholesterol", "mg"),
        "salt_100g": ("Salt", "g"),
    }

    key_names = {"Calories", "Protein", "Total Fat", "Carbohydrates", "Fiber",
                 "Sugars", "Sodium", "Saturated Fat", "Cholesterol"}

    nutrients = {}
    for off_key, (name, unit) in mapping.items():
        if off_key in nutriments:
            if include_all or name in key_names:
                amount = nutriments[off_key]
                # Convert sodium from g to mg for consistency
                if name == "Sodium" and unit == "g":
                    amount = amount * 1000
                    unit = "mg"
                nutrients[name] = {
                    "amount": round(amount, 2) if amount else 0,
                    "unit": unit
                }

    return nutrients


# =============================================================================
# Command handlers
# =============================================================================

def cmd_search(args):
    """Handle search command"""
    if args.source == "off":
        output = off_search(args)
    else:
        output = usda_search(args)

    if args.json:
        print(json.dumps(output, indent=2))
    else:
        print_search_table(output)


def cmd_info(args):
    """Handle info command"""
    if args.source == "off":
        result = off_info(args.food_id, include_all=args.all_nutrients)
    else:
        result = usda_info(args.food_id, include_all=args.all_nutrients)

    if args.json:
        print(json.dumps(result, indent=2))
    else:
        print_info_table(result)


def cmd_nutrients(args):
    """Handle nutrients command"""
    if args.source == "off":
        result = off_info(args.food_id, include_all=args.all)
    else:
        result = usda_info(args.food_id, include_all=args.all)

    # Slim down for nutrients-only output
    result = {
        "source": result["source"],
        "id": result["id"],
        "description": result["description"],
        "servingSize": result.get("servingSize"),
        "nutrients": result["nutrients"]
    }

    if args.json:
        print(json.dumps(result, indent=2))
    else:
        print(f"\nNutrients for: {result['description']}")
        if result.get("servingSize"):
            print(f"Per {result['servingSize']}")
        print(f"Source: {result['source'].upper()}\n")
        for name, val in result["nutrients"].items():
            print(f"  {name}: {val['amount']} {val['unit']}")


# =============================================================================
# Output formatting
# =============================================================================

def print_search_table(data):
    """Print search results as human-readable table"""
    source = data.get("source", "").upper()
    print(f"\n[{source}] Found {data['totalHits']} results for '{data['query']}'")
    print(f"Page {data['currentPage']} of {data['totalPages']}\n")

    print(f"{'ID':<15} {'Description':<45} {'Brand':<15} {'Cal':>6}")
    print("-" * 85)

    for food in data["foods"]:
        fid = str(food.get("id") or "")[:14]
        desc = (food.get("description") or "")[:44]
        brand = (food.get("brand") or "")[:14]
        cal = food.get("nutrients", {}).get("Calories", {}).get("amount", "-")
        print(f"{fid:<15} {desc:<45} {brand:<15} {cal:>6}")


def print_info_table(data):
    """Print food info as human-readable format"""
    print(f"\n{data.get('description')}")
    print(f"ID: {data.get('id')} | Source: {data.get('source', '').upper()}")

    if data.get("brand"):
        print(f"Brand: {data['brand']}")

    serving = []
    if data.get("servingSize"):
        unit = data.get("servingSizeUnit", "")
        serving.append(f"{data['servingSize']} {unit}".strip())
    if data.get("servingDescription"):
        serving.append(str(data["servingDescription"]))
    if serving:
        print(f"Serving: {' | '.join(serving)}")

    if data.get("ingredients"):
        ing = data["ingredients"][:200]
        print(f"\nIngredients: {ing}{'...' if len(data['ingredients']) > 200 else ''}")

    print(f"\n{'Nutrient':<20} {'Amount':>12}")
    print("-" * 34)

    priority = ["Calories", "Protein", "Total Fat", "Saturated Fat", "Carbohydrates",
                "Fiber", "Sugars", "Sodium", "Cholesterol"]
    sorted_nutrients = sorted(
        data.get("nutrients", {}).items(),
        key=lambda x: priority.index(x[0]) if x[0] in priority else 999
    )

    for name, val in sorted_nutrients:
        amount = f"{val['amount']} {val['unit']}"
        print(f"{name:<20} {amount:>12}")


# =============================================================================
# Main
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="FoodCLI - Nutrition lookup from USDA and Open Food Facts",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  food search "chicken breast"                    # Search USDA (default)
  food search "nutella" --source off              # Search Open Food Facts
  food search "protein bar" --type branded        # USDA branded foods only
  food info 746771                                # USDA food by FDC ID
  food info 3017620422003 --source off            # OFF product by barcode
  food nutrients 746771 --all                     # All nutrients

Sources:
  usda  - USDA FoodData Central (requires API key, US foods)
  off   - Open Food Facts (no API key, global products, barcodes)

Config (~/.config/foodcli/config.json):
  {"api_key": "YOUR_USDA_KEY"}   # Only needed for USDA
        """
    )

    parser.add_argument("--json", "-j", action="store_true",
                        help="JSON output (for LLM/programmatic use)")
    parser.add_argument("--source", "-s", choices=["usda", "off"], default="usda",
                        help="Data source: usda (default) or off (Open Food Facts)")

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # Search command
    search_p = subparsers.add_parser("search", aliases=["s"], help="Search for foods")
    search_p.add_argument("query", help="Search query")
    search_p.add_argument("-l", "--limit", type=int, default=25, help="Results per page")
    search_p.add_argument("-p", "--page", type=int, default=1, help="Page number")
    search_p.add_argument("--all", action="store_true", help="Fetch all pages")
    search_p.add_argument("--type", choices=["branded", "foundation", "survey", "legacy"],
                          help="Filter by data type (USDA only)")
    search_p.add_argument("--brand", help="Filter by brand (USDA only)")
    search_p.add_argument("--source", "-s", choices=["usda", "off"], default="usda",
                          help="Data source")
    search_p.add_argument("--json", "-j", action="store_true", help="JSON output")

    # Info command
    info_p = subparsers.add_parser("info", aliases=["i"], help="Get detailed food info")
    info_p.add_argument("food_id", help="FDC ID (USDA) or barcode (OFF)")
    info_p.add_argument("--all-nutrients", "-a", action="store_true",
                        help="Include all nutrients")
    info_p.add_argument("--source", "-s", choices=["usda", "off"], default="usda",
                        help="Data source")
    info_p.add_argument("--json", "-j", action="store_true", help="JSON output")

    # Nutrients command
    nutrients_p = subparsers.add_parser("nutrients", aliases=["n"], help="Get nutrient breakdown")
    nutrients_p.add_argument("food_id", help="FDC ID (USDA) or barcode (OFF)")
    nutrients_p.add_argument("--all", "-a", action="store_true", help="Include all nutrients")
    nutrients_p.add_argument("--source", "-s", choices=["usda", "off"], default="usda",
                             help="Data source")
    nutrients_p.add_argument("--json", "-j", action="store_true", help="JSON output")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(0)

    if args.command in ("search", "s"):
        cmd_search(args)
    elif args.command in ("info", "i"):
        cmd_info(args)
    elif args.command in ("nutrients", "n"):
        cmd_nutrients(args)


if __name__ == "__main__":
    main()
